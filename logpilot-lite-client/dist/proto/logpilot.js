"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v5.29.3
// source: logpilot.proto
Object.defineProperty(exports, "__esModule", { value: true });
exports.LogServiceClient = exports.LogServiceService = exports.ListLogsResponse = exports.LogEntry_MetaEntry = exports.LogEntry = exports.FetchLogsResponse = exports.FetchLogsRequest = exports.ListLogsRequest = exports.LogResponse = exports.LogRequest_MetaEntry = exports.LogRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const wire_1 = require("@bufbuild/protobuf/wire");
const grpc_js_1 = require("@grpc/grpc-js");
exports.protobufPackage = "logpilot";
function createBaseLogRequest() {
    return { channel: "", level: "", message: "", meta: {}, storage: "" };
}
exports.LogRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.channel !== "") {
            writer.uint32(10).string(message.channel);
        }
        if (message.level !== "") {
            writer.uint32(18).string(message.level);
        }
        if (message.message !== "") {
            writer.uint32(26).string(message.message);
        }
        Object.entries(message.meta).forEach(([key, value]) => {
            exports.LogRequest_MetaEntry.encode({ key: key, value }, writer.uint32(34).fork()).join();
        });
        if (message.storage !== "") {
            writer.uint32(42).string(message.storage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLogRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.channel = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.level = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = exports.LogRequest_MetaEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.meta[entry4.key] = entry4.value;
                    }
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.storage = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
            level: isSet(object.level) ? globalThis.String(object.level) : "",
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            meta: isObject(object.meta)
                ? Object.entries(object.meta).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            storage: isSet(object.storage) ? globalThis.String(object.storage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.channel !== "") {
            obj.channel = message.channel;
        }
        if (message.level !== "") {
            obj.level = message.level;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.meta) {
            const entries = Object.entries(message.meta);
            if (entries.length > 0) {
                obj.meta = {};
                entries.forEach(([k, v]) => {
                    obj.meta[k] = v;
                });
            }
        }
        if (message.storage !== "") {
            obj.storage = message.storage;
        }
        return obj;
    },
    create(base) {
        return exports.LogRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLogRequest();
        message.channel = object.channel ?? "";
        message.level = object.level ?? "";
        message.message = object.message ?? "";
        message.meta = Object.entries(object.meta ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.storage = object.storage ?? "";
        return message;
    },
};
function createBaseLogRequest_MetaEntry() {
    return { key: "", value: "" };
}
exports.LogRequest_MetaEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLogRequest_MetaEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.LogRequest_MetaEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLogRequest_MetaEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseLogResponse() {
    return { status: "", message: "" };
}
exports.LogResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.status !== "") {
            writer.uint32(10).string(message.status);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLogResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.status = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            status: isSet(object.status) ? globalThis.String(object.status) : "",
            message: isSet(object.message) ? globalThis.String(object.message) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.status !== "") {
            obj.status = message.status;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return exports.LogResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLogResponse();
        message.status = object.status ?? "";
        message.message = object.message ?? "";
        return message;
    },
};
function createBaseListLogsRequest() {
    return { storage: "", channel: "", level: "", fromTimestamp: 0, toTimestamp: 0 };
}
exports.ListLogsRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.storage !== "") {
            writer.uint32(10).string(message.storage);
        }
        if (message.channel !== "") {
            writer.uint32(18).string(message.channel);
        }
        if (message.level !== "") {
            writer.uint32(26).string(message.level);
        }
        if (message.fromTimestamp !== 0) {
            writer.uint32(32).int64(message.fromTimestamp);
        }
        if (message.toTimestamp !== 0) {
            writer.uint32(40).int64(message.toTimestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListLogsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.storage = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.channel = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.level = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.fromTimestamp = longToNumber(reader.int64());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.toTimestamp = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            storage: isSet(object.storage) ? globalThis.String(object.storage) : "",
            channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
            level: isSet(object.level) ? globalThis.String(object.level) : "",
            fromTimestamp: isSet(object.fromTimestamp) ? globalThis.Number(object.fromTimestamp) : 0,
            toTimestamp: isSet(object.toTimestamp) ? globalThis.Number(object.toTimestamp) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.storage !== "") {
            obj.storage = message.storage;
        }
        if (message.channel !== "") {
            obj.channel = message.channel;
        }
        if (message.level !== "") {
            obj.level = message.level;
        }
        if (message.fromTimestamp !== 0) {
            obj.fromTimestamp = Math.round(message.fromTimestamp);
        }
        if (message.toTimestamp !== 0) {
            obj.toTimestamp = Math.round(message.toTimestamp);
        }
        return obj;
    },
    create(base) {
        return exports.ListLogsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListLogsRequest();
        message.storage = object.storage ?? "";
        message.channel = object.channel ?? "";
        message.level = object.level ?? "";
        message.fromTimestamp = object.fromTimestamp ?? 0;
        message.toTimestamp = object.toTimestamp ?? 0;
        return message;
    },
};
function createBaseFetchLogsRequest() {
    return { since: "", channel: "", limit: 0 };
}
exports.FetchLogsRequest = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.since !== "") {
            writer.uint32(10).string(message.since);
        }
        if (message.channel !== "") {
            writer.uint32(18).string(message.channel);
        }
        if (message.limit !== 0) {
            writer.uint32(24).int32(message.limit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFetchLogsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.since = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.channel = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.limit = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            since: isSet(object.since) ? globalThis.String(object.since) : "",
            channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
            limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.since !== "") {
            obj.since = message.since;
        }
        if (message.channel !== "") {
            obj.channel = message.channel;
        }
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        return obj;
    },
    create(base) {
        return exports.FetchLogsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFetchLogsRequest();
        message.since = object.since ?? "";
        message.channel = object.channel ?? "";
        message.limit = object.limit ?? 0;
        return message;
    },
};
function createBaseFetchLogsResponse() {
    return { logs: [] };
}
exports.FetchLogsResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.logs) {
            exports.LogEntry.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFetchLogsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.logs.push(exports.LogEntry.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e) => exports.LogEntry.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.logs?.length) {
            obj.logs = message.logs.map((e) => exports.LogEntry.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.FetchLogsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFetchLogsResponse();
        message.logs = object.logs?.map((e) => exports.LogEntry.fromPartial(e)) || [];
        return message;
    },
};
function createBaseLogEntry() {
    return { channel: "", level: "", message: "", meta: {}, timestamp: 0 };
}
exports.LogEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.channel !== "") {
            writer.uint32(10).string(message.channel);
        }
        if (message.level !== "") {
            writer.uint32(18).string(message.level);
        }
        if (message.message !== "") {
            writer.uint32(26).string(message.message);
        }
        Object.entries(message.meta).forEach(([key, value]) => {
            exports.LogEntry_MetaEntry.encode({ key: key, value }, writer.uint32(34).fork()).join();
        });
        if (message.timestamp !== 0) {
            writer.uint32(40).int64(message.timestamp);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLogEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.channel = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.level = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = exports.LogEntry_MetaEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.meta[entry4.key] = entry4.value;
                    }
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.timestamp = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            channel: isSet(object.channel) ? globalThis.String(object.channel) : "",
            level: isSet(object.level) ? globalThis.String(object.level) : "",
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            meta: isObject(object.meta)
                ? Object.entries(object.meta).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.channel !== "") {
            obj.channel = message.channel;
        }
        if (message.level !== "") {
            obj.level = message.level;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.meta) {
            const entries = Object.entries(message.meta);
            if (entries.length > 0) {
                obj.meta = {};
                entries.forEach(([k, v]) => {
                    obj.meta[k] = v;
                });
            }
        }
        if (message.timestamp !== 0) {
            obj.timestamp = Math.round(message.timestamp);
        }
        return obj;
    },
    create(base) {
        return exports.LogEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLogEntry();
        message.channel = object.channel ?? "";
        message.level = object.level ?? "";
        message.message = object.message ?? "";
        message.meta = Object.entries(object.meta ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.timestamp = object.timestamp ?? 0;
        return message;
    },
};
function createBaseLogEntry_MetaEntry() {
    return { key: "", value: "" };
}
exports.LogEntry_MetaEntry = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLogEntry_MetaEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.LogEntry_MetaEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLogEntry_MetaEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseListLogsResponse() {
    return { logs: [] };
}
exports.ListLogsResponse = {
    encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.logs) {
            exports.LogEntry.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        const end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseListLogsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.logs.push(exports.LogEntry.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e) => exports.LogEntry.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.logs?.length) {
            obj.logs = message.logs.map((e) => exports.LogEntry.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.ListLogsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseListLogsResponse();
        message.logs = object.logs?.map((e) => exports.LogEntry.fromPartial(e)) || [];
        return message;
    },
};
exports.LogServiceService = {
    sendLog: {
        path: "/logpilot.LogService/SendLog",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.LogRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.LogRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.LogResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.LogResponse.decode(value),
    },
    listLogs: {
        path: "/logpilot.LogService/ListLogs",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.ListLogsRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.ListLogsRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.ListLogsResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.ListLogsResponse.decode(value),
    },
    fetchLogs: {
        path: "/logpilot.LogService/FetchLogs",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(exports.FetchLogsRequest.encode(value).finish()),
        requestDeserialize: (value) => exports.FetchLogsRequest.decode(value),
        responseSerialize: (value) => Buffer.from(exports.FetchLogsResponse.encode(value).finish()),
        responseDeserialize: (value) => exports.FetchLogsResponse.decode(value),
    },
};
exports.LogServiceClient = (0, grpc_js_1.makeGenericClientConstructor)(exports.LogServiceService, "logpilot.LogService");
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
